import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { GeminiLLM } from "../../../gemini-llm.ts";

// Declare collection prefix, use concept name
const PREFIX = "Translation" + ".";

// Generic types of this concept
type FilePath = ID; // Represents a file path
type TransTextId = string; // Unique identifier for translated text
type TargetLanguage = string; // Language code (e.g., "en", "fr")
type OriginalTextId = ID; // Unique identifier for original text

/**
 * Represents a translation entry.
 */
interface Translations {
  _id: TransTextId; // Unique identifier for the translation
  imagePath: FilePath; // Path to the image associated with the translation
  targetLanguage: TargetLanguage; // The language the text was translated into
  originalTextId: OriginalTextId; // ID of the original text
  translatedText: string; // The translated text
}

export default class TranslationConcept {
  translations: Collection<Translations>;
  private readonly geminiLLM: GeminiLLM;

  constructor(private readonly db: Db) {
    this.translations = this.db.collection(PREFIX + "translations");
    this.geminiLLM = new GeminiLLM();
  }

  /**
   * createTranslation (imagePath: filePath, targetLanguage: String, originalText: String, originalTextId: String): (translation: Translation)
   *
   * **requires**: `imagePath` exists in the app. `targetLanguage` is a real language.
   *
   * **effects**: Generates a `Translation` with a unique `transTextId` based on `imagePath` and `originalTextId`. `translatedText` is generated by the AI in the `targetLanguage` from the `originalText`. Stores the `targetLanguage` and `originalText`.
   */
  async createTranslation({
    imagePath,
    targetLanguage,
    originalText,
    originalTextId,
  }: {
    imagePath: FilePath;
    targetLanguage: TargetLanguage;
    originalText: string;
    originalTextId: OriginalTextId;
  }): Promise<{ translation: TransTextId } | { error: string }> {
    try {
      const transTextId =
        `${originalTextId}:${targetLanguage}:${Date.now()}` as TransTextId; // Simple ID generation for now

      // Use GeminiLLM for translation
      const prompt =
        `Translate the following text to ${targetLanguage}: "${originalText}"`;
      const translatedText = await this.geminiLLM.executeLLM(prompt); // Assume GeminiLLM handles imagePath if needed in future

      const newTranslation: Translations = {
        _id: transTextId,
        imagePath: imagePath,
        targetLanguage: targetLanguage,
        originalTextId: originalTextId,
        translatedText: translatedText,
      };

      await this.translations.insertOne(newTranslation);

      return { translation: transTextId };
    } catch (error) {
      console.error("Error creating translation:", error);
      // Return an error object as per the documentation for normal errors
      return { error: (error as Error).message };
    }
  }

  /**
   * editTranslation (translation: Translation, newText: String)
   *
   * **requires**: `translation` exists.
   *
   * **effects**: Changes the `translatedText` in the `translation` to `newText`.
   */
  async editTranslation({
    translation,
    newText,
  }: {
    translation: TransTextId;
    newText: string;
  }): Promise<Empty | { error: string }> {
    try {
      const result = await this.translations.updateOne(
        { _id: translation },
        { $set: { translatedText: newText } },
      );

      if (result.matchedCount === 0) {
        throw new Error(`Translation with ID ${translation} not found.`);
      }
      return {};
    } catch (error) {
      console.error("Error editing translation:", error);
      return { error: (error as Error).message };
    }
  }

  /**
   * changeLanguage (translation: Translation, newTargetLang: String)
   *
   * **requires**: `extractedText` exists. `newTargetLang` is a real language.
   *
   * **effects**: Changes the `targetLanguage` to `newTargetLang`. Sets `translatedText` to a new translated version in the `newTargetLang` generated by the AI.
   */
  async changeLanguage({
    translation,
    newTargetLang,
  }: {
    translation: TransTextId;
    newTargetLang: TargetLanguage;
  }): Promise<{ translation: TransTextId } | { error: string }> {
    try {
      const existingTranslation = await this.translations.findOne({
        _id: translation,
      });

      if (!existingTranslation) {
        throw new Error(`Translation with ID ${translation} not found.`);
      }

      // Use GeminiLLM for translation to the new language
      const prompt =
        `Translate the following text to ${newTargetLang}: "${existingTranslation.translatedText}"`;
      const translatedText = await this.geminiLLM.executeLLM(prompt);

      // Update the translation document
      await this.translations.updateOne(
        { _id: translation },
        {
          $set: {
            targetLanguage: newTargetLang,
            translatedText: translatedText,
          },
        },
      );

      return { translation: translation }; // Return the updated translation ID
    } catch (error) {
      console.error("Error changing language:", error);
      return { error: (error as Error).message };
    }
  }

  // --- Queries (optional, but good for testing and inspection) ---

  /**
   * _getTranslationById (translationId: TransTextId): (translation: Translations)
   *
   * **requires**: `translationId` exists.
   *
   * **effects**: Returns the full translation object for the given ID.
   */
  async _getTranslationById(
    translationId: TransTextId,
  ): Promise<Translations[]> {
    try {
      const translation = await this.translations.findOne({
        _id: translationId,
      });
      if (translation) {
        return [translation];
      } else {
        return [];
      }
    } catch (error) {
      console.error("Error getting translation by ID:", error);
      return [{ error: (error as Error).message } as any]; // Indicate error in the result array
    }
  }

  /**
   * _getTranslationsByOriginalTextId (originalTextId: OriginalTextId): (translations: Translations)
   *
   * **requires**: `originalTextId` exists.
   *
   * **effects**: Returns all translations associated with the given original text ID.
   */
  async _getTranslationsByOriginalTextId(
    originalTextId: OriginalTextId,
  ): Promise<Translations[]> {
    try {
      const cursor = this.translations.find({ originalTextId: originalTextId });
      const translations = await cursor.toArray();
      return translations;
    } catch (error) {
      console.error("Error getting translations by original text ID:", error);
      return [{ error: (error as Error).message } as any]; // Indicate error in the result array
    }
  }
}
