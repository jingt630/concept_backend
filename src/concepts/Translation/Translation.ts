import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";
import { GeminiLLM } from "../../../gemini-llm.ts";

// Declare collection prefix, use concept name
const PREFIX = "Translation" + ".";

// Generic types of this concept
type FilePath = ID; // Represents a file path
type TransTextId = string; // Unique identifier for translated text
type TargetLanguage = string; // Language code (e.g., "en", "fr")
type OriginalTextId = ID; // Unique identifier for original text

/**
 * Represents a translation entry.
 */
interface Translations {
  _id: TransTextId; // Unique identifier for the translation
  imagePath: FilePath; // Path to the image associated with the translation
  targetLanguage: TargetLanguage; // The language the text was translated into
  originalTextId: OriginalTextId; // ID of the original text
  translatedText: string; // The translated text
}

export default class TranslationConcept {
  translations: Collection<Translations>;
  private readonly geminiLLM: GeminiLLM;

  constructor(private readonly db: Db) {
    this.translations = this.db.collection(PREFIX + "translations");
    this.geminiLLM = new GeminiLLM();
  }

  /**
   * createTranslation (userId: ID, imagePath: filePath, targetLanguage: String, originalText: String, originalTextId: String): (translation: Translation)
   *
   * **requires**: `imagePath` exists in the app. `targetLanguage` is a real language.
   *
   * **effects**: Generates a `Translation` with a unique `transTextId` based on `imagePath` and `originalTextId`. `translatedText` is generated by the AI in the `targetLanguage` from the `originalText`. Stores the `targetLanguage` and `originalText`.
   */
  async createTranslation({
    userId,
    imagePath,
    targetLanguage,
    originalText,
    originalTextId,
  }: {
    userId: ID;
    imagePath: FilePath;
    targetLanguage: TargetLanguage;
    originalText: string;
    originalTextId: OriginalTextId;
  }): Promise<{ translation: TransTextId; translatedText: string } | { error: string }> {
    try {
      console.log(`üåê Starting translation for text: "${originalText}" to ${targetLanguage}`);

      const transTextId = freshID() as TransTextId;

      // Language mapping for better AI prompts
      const languageNames: Record<string, string> = {
        'en': 'English',
        'es': 'Spanish',
        'zh': 'Chinese',
        'ja': 'Japanese'
      };

      const targetLanguageName = languageNames[targetLanguage] || targetLanguage;

      // Use GeminiLLM for translation with better prompt
      const prompt = `You are a professional translator. Translate the following text to ${targetLanguageName}.

Original text: "${originalText}"

Requirements:
- Provide ONLY the translated text
- No explanations or notes
- Maintain the original meaning and tone
- If it's already in ${targetLanguageName}, just return the original text

Translation:`;

      console.log(`ü§ñ Calling Gemini AI for translation...`);
      const translatedText = await this.geminiLLM.executeLLM(prompt);
      console.log(`‚úÖ Translation received: "${translatedText}"`);

      const newTranslation: Translations = {
        _id: transTextId,
        imagePath: imagePath,
        targetLanguage: targetLanguage,
        originalTextId: originalTextId,
        translatedText: translatedText.trim(),
      };

      await this.translations.insertOne(newTranslation);
      console.log(`‚úÖ Translation stored in database: ${transTextId}`);

      return { translation: transTextId, translatedText: translatedText.trim() };
    } catch (error) {
      console.error("‚ùå Error creating translation:", error);
      return { error: (error as Error).message };
    }
  }

  /**
   * editTranslation (translation: Translation, newText: String)
   *
   * **requires**: `translation` exists.
   *
   * **effects**: Changes the `translatedText` in the `translation` to `newText`.
   */
  async editTranslation({
    translation,
    newText,
  }: {
    translation: TransTextId;
    newText: string;
  }): Promise<Empty | { error: string }> {
    try {
      const result = await this.translations.updateOne(
        { _id: translation },
        { $set: { translatedText: newText } },
      );

      if (result.matchedCount === 0) {
        throw new Error(`Translation with ID ${translation} not found.`);
      }
      return {};
    } catch (error) {
      console.error("Error editing translation:", error);
      return { error: (error as Error).message };
    }
  }

  /**
   * changeLanguage (translation: Translation, newTargetLang: String)
   *
   * **requires**: `extractedText` exists. `newTargetLang` is a real language.
   *
   * **effects**: Changes the `targetLanguage` to `newTargetLang`. Sets `translatedText` to a new translated version in the `newTargetLang` generated by the AI.
   */
  async changeLanguage({
    translation,
    newTargetLang,
  }: {
    translation: TransTextId;
    newTargetLang: TargetLanguage;
  }): Promise<{ translation: TransTextId } | { error: string }> {
    try {
      const existingTranslation = await this.translations.findOne({
        _id: translation,
      });

      if (!existingTranslation) {
        throw new Error(`Translation with ID ${translation} not found.`);
      }

      // Use GeminiLLM for translation to the new language
      const prompt =
        `Translate the following text to ${newTargetLang}: "${existingTranslation.translatedText}"`;
      const translatedText = await this.geminiLLM.executeLLM(prompt);

      // Update the translation document
      await this.translations.updateOne(
        { _id: translation },
        {
          $set: {
            targetLanguage: newTargetLang,
            translatedText: translatedText,
          },
        },
      );

      return { translation: translation }; // Return the updated translation ID
    } catch (error) {
      console.error("Error changing language:", error);
      return { error: (error as Error).message };
    }
  }

  // --- Queries (optional, but good for testing and inspection) ---

  /**
   * _getTranslationById (translationId: TransTextId): (translation: Translations)
   *
   * **requires**: `translationId` exists.
   *
   * **effects**: Returns the full translation object for the given ID.
   */
  async _getTranslationById(
    translationId: TransTextId,
  ): Promise<Translations[]> {
    try {
      const translation = await this.translations.findOne({
        _id: translationId,
      });
      if (translation) {
        return [translation];
      } else {
        return [];
      }
    } catch (error) {
      console.error("Error getting translation by ID:", error);
      return [{ error: (error as Error).message } as any]; // Indicate error in the result array
    }
  }

  /**
   * _getTranslationsByOriginalTextId (userId: ID, originalTextId: OriginalTextId): (translations: Translations)
   *
   * **requires**: `originalTextId` exists.
   *
   * **effects**: Returns all translations associated with the given original text ID.
   */
  async _getTranslationsByOriginalTextId({
    userId,
    originalTextId,
  }: {
    userId: ID;
    originalTextId: OriginalTextId;
  }): Promise<Translations[]> {
    try {
      console.log(`üîç Searching translations for originalTextId: ${originalTextId}`);
      const cursor = this.translations.find({ originalTextId: originalTextId });
      const translations = await cursor.toArray();
      console.log(`üìä Found ${translations.length} translations:`, translations);
      return translations;
    } catch (error) {
      console.error("‚ùå Error getting translations by original text ID:", error);
      return [{ error: (error as Error).message } as any]; // Indicate error in the result array
    }
  }
}
