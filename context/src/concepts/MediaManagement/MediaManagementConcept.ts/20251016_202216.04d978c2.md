---
timestamp: 'Thu Oct 16 2025 20:22:16 GMT-0400 (Eastern Daylight Time)'
content_id: 04d978c2ac2c2a4cee37a80703ef4cd6f0f88599bf63f2b57d339ac6173c0ad8
---

# file: src\concepts\MediaManagement\MediaManagementConcept.ts

```typescript
import { Collection, Db, ObjectId } from "npm:mongodb";
import { Empty, ID, Type } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Generic types for the MediaManagement concept
type MediaItem = ID; // Represents an identifier for a media item
type User = ID; // Represents an identifier for a user

// Define the structure for media items in the database

interface MediaItems {
  _id: MediaItem;
  owner: User;
  url: string;
  fileName: string;
  fileType: string;
  uploadTimestamp: Date;
  updateTimestamp: Date;
  accessControl: "public" | "private";
}

// Define the structure for access control records in the database
interface AccessControlRecords {
  _id: ID; // Generic ID for the access control record
  mediaItemId: MediaItem;
  userId: User;
  accessLevel: "read" | "write"; // For future extensibility, currently only 'read' is implied
}

const PREFIX = "MediaManagement" + ".";

export default class MediaManagementConcept {
  mediaItems: Collection<MediaItems>;
  accessControlRecords: Collection<AccessControlRecords>;

  constructor(private readonly db: Db) {
    this.mediaItems = this.db.collection(PREFIX + "mediaItems");
    this.accessControlRecords = this.db.collection(PREFIX + "accessControlRecords");
  }

  /**
   * uploadMedia (owner: User, url: string, fileName: string, fileType: string): (mediaItem: MediaItem)
   *
   * **purpose**: Allow users to upload media items and associate them with their account.
   *
   * **principle**: If a user uploads a media file, it becomes available under their account for later access.
   *
   * **state**:
   *   a set of MediaItems with
   *     an owner User
   *     a url String
   *     a fileName String
   *     a fileType String
   *     an uploadTimestamp Date
   *     an updateTimestamp Date
   *     an accessControl String ("public" or "private")
   *
   * **requires**: `owner` is a valid User ID. `url`, `fileName`, `fileType` are non-empty strings.
   *
   * **effects**: Creates a new MediaItem `m`; sets `m.owner` to `owner`; sets `m.url` to `url`; sets `m.fileName` to `fileName`; sets `m.fileType` to `fileType`; sets `m.uploadTimestamp` to the current time; sets `m.accessControl` to "private" by default; returns `m._id` as `mediaItem`.
   */
  async uploadMedia({
    owner,url,fileName,fileType,}: {owner: User;url: string;fileName: string;fileType: string;})
    : Promise<{ mediaItem: MediaItem }> {
    if (!owner || !url || !fileName || !fileType) {
      return { error: "Missing required fields for media upload." };
    }

    const today = new Date();

    const newMediaItem: MediaItems = {
      _id: freshID(),
      owner: owner,
      url: url,
      fileName: fileName,
      fileType: fileType,
      uploadTimestamp: today,
      updateTimestamp: today, // Not needed as per current requirements
      accessControl: "private", // Default to private
    };

    await this.mediaItems.insertOne(newMediaItem);
    return { mediaItem: newMediaItem._id };
  }

  /**
   * setMediaAccess (mediaItem: MediaItem, access: "public" | "private"): Empty
   *
   * **purpose**: Control the visibility and accessibility of uploaded media items.
   *
   * **principle**: If a user sets a media item to public, it can be accessed by anyone; if set to private, only the owner (and explicitly granted users) can access it.
   *
   * **state**: (See `uploadMedia` for MediaItems state)
   *
   * **requires**: `mediaItem` is a valid MediaItem ID. `access` is either "public" or "private".
   *
   * **effects**: Updates the `accessControl` field of the specified MediaItem `m` to `access`. If `access` is "public", any associated access control records for this `mediaItem` are removed.
   */
  async setMediaAccess({
    mediaItem,
    access,
  }: {
    mediaItem: MediaItem;
    access: "public" | "private";
  }): Promise<Empty> {
    if (!mediaItem || (access !== "public" && access !== "private")) {
      return { error: "Invalid parameters for setting media access." };
    }

    const updateResult = await this.mediaItems.updateOne(
      { _id: mediaItem },
      { $set: { accessControl: access } }
    );

    if (updateResult.matchedCount === 0) {
      return { error: `Media item with ID ${mediaItem} not found.` };
    }

    if (access === "public") {
      // If set to public, remove any specific access control records for this item
      await this.accessControlRecords.deleteMany({ mediaItemId: mediaItem });
    }

    return {};
  }

  /**
   * grantMediaAccess (mediaItem: MediaItem, userId: User, access: "read"): Empty
   *
   * **purpose**: Allow specific users to access private media items.
   *
   * **principle**: If a user is granted read access to a private media item, they can access it even if they are not the owner.
   *
   * **state**: (See `uploadMedia` for MediaItems state and AccessControlRecords state)
   *
   * **requires**: `mediaItem` is a valid MediaItem ID. `userId` is a valid User ID. `access` is "read". The `mediaItem` must be set to "private".
   *
   * **effects**: Creates a new AccessControlRecord `acr`; sets `acr.mediaItemId` to `mediaItem`; sets `acr.userId` to `userId`; sets `acr.accessLevel` to `access`. If the `mediaItem` is public, this action has no effect.
   */
  async grantMediaAccess({
    mediaItem,
    userId,
    access,
  }: {
    mediaItem: MediaItem;
    userId: User;
    access: "read";
  }): Promise<Empty> {
    if (!mediaItem || !userId || access !== "read") {
      return { error: "Invalid parameters for granting media access." };
    }

    const media = await this.mediaItems.findOne({ _id: mediaItem });
    if (!media) {
      return { error: `Media item with ID ${mediaItem} not found.` };
    }

    if (media.accessControl === "public") {
      // No need to grant specific access if the item is already public
      return {};
    }

    // Check if access is already granted
    const existingAccess = await this.accessControlRecords.findOne({
      mediaItemId: mediaItem,
      userId: userId,
    });
    if (existingAccess) {
      // Access already granted, no action needed or could be considered an error
      // For now, let's assume no action is needed.
      return {};
    }

    const newAccessRecord: AccessControlRecords = {
      _id: freshID(),
      mediaItemId: mediaItem,
      userId: userId,
      accessLevel: access,
    };

    await this.accessControlRecords.insertOne(newAccessRecord);
    return {};
  }

  /**
   * revokeMediaAccess (mediaItem: MediaItem, userId: User): Empty
   *
   * **purpose**: Remove specific user's access to a private media item.
   *
   * **principle**: If a user's access to a private media item is revoked, they can no longer access it.
   *
   * **state**: (See `uploadMedia` for MediaItems state and AccessControlRecords state)
   *
   * **requires**: `mediaItem` is a valid MediaItem ID. `userId` is a valid User ID.
   *
   * **effects**: Removes any AccessControlRecord `acr` where `acr.mediaItemId` is `mediaItem` and `acr.userId` is `userId`. If the `mediaItem` is public, this action has no effect.
   */
  async revokeMediaAccess({
    mediaItem,
    userId,
  }: {
    mediaItem: MediaItem;
    userId: User;
  }): Promise<Empty> {
    if (!mediaItem || !userId) {
      return { error: "Invalid parameters for revoking media access." };
    }

    // Check if the media item is public, if so, revoking specific access is moot.
    const media = await this.mediaItems.findOne({ _id: mediaItem });
    if (!media) {
      return { error: `Media item with ID ${mediaItem} not found.` };
    }

    if (media.accessControl === "public") {
      // If public, there are no specific access control records to revoke.
      return {};
    }

    await this.accessControlRecords.deleteOne({
      mediaItemId: mediaItem,
      userId: userId,
    });

    return {};
  }

  /**
   * getMediaItem (mediaItem: MediaItem, requestingUser: User): (mediaItem: MediaItems) | { error: string }
   *
   * **purpose**: Retrieve details of a specific media item, enforcing access controls.
   *
   * **principle**: If a user requests a media item and it is public, or they are the owner, or they have been granted explicit read access, they will receive the media item's details. Otherwise, access is denied.
   *
   * **state**: (See `uploadMedia` for MediaItems state and AccessControlRecords state)
   *
   * **requires**: `mediaItem` is a valid MediaItem ID. `requestingUser` is a valid User ID.
   *
   * **effects**: Returns the MediaItem object if the `requestingUser` has permission. Otherwise, returns an error.
   */
  async getMediaItem({
    mediaItem,
    requestingUser,
  }: {
    mediaItem: MediaItem;
    requestingUser: User;
  }): Promise<MediaItems | { error: string }> {
    if (!mediaItem || !requestingUser) {
      return { error: "Invalid parameters for getting media item." };
    }

    const media = await this.mediaItems.findOne({ _id: mediaItem });
    if (!media) {
      return { error: `Media item with ID ${mediaItem} not found.` };
    }

    // Check if the media is public
    if (media.accessControl === "public") {
      return media;
    }

    // Check if the requesting user is the owner
    if (media.owner === requestingUser) {
      return media;
    }

    // Check if the requesting user has explicit read access
    const accessGranted = await this.accessControlRecords.findOne({
      mediaItemId: mediaItem,
      userId: requestingUser,
      accessLevel: "read",
    });

    if (accessGranted) {
      return media;
    }

    return { error: "Access denied to media item." };
  }

  /**
   * getUserMediaItems (user: User): (mediaItems: MediaItems[])
   *
   * **purpose**: Retrieve all media items owned by a specific user.
   *
   * **principle**: If a user requests their media items, all items they have uploaded will be returned.
   *
   * **state**: (See `uploadMedia` for MediaItems state)
   *
   * **requires**: `user` is a valid User ID.
   *
   * **effects**: Returns an array of MediaItem objects owned by the specified `user`.
   */
  async getUserMediaItems({ user }: { user: User }): Promise<{ mediaItems: MediaItems[] }> {
    if (!user) {
      return { error: "Invalid parameters for getting user media items." };
    }

    const mediaItems = await this.mediaItems.find({ owner: user }).toArray();
    return { mediaItems };
  }

  /**
   * deleteMediaItem (mediaItem: MediaItem, requestingUser: User): Empty
   *
   * **purpose**: Allow users to delete their uploaded media items.
   *
   * **principle**: If a user deletes a media item they own, it is permanently removed.
   *
   * **state**: (See `uploadMedia` for MediaItems state and AccessControlRecords state)
   *
   * **requires**: `mediaItem` is a valid MediaItem ID. `requestingUser` is a valid User ID. The `requestingUser` must be the owner of the `mediaItem`.
   *
   * **effects**: Deletes the specified MediaItem `m`. Deletes any associated AccessControlRecords for `m`.
   */
  async deleteMediaItem({
    mediaItem,
    requestingUser,
  }: {
    mediaItem: MediaItem;
    requestingUser: User;
  }): Promise<Empty> {
    if (!mediaItem || !requestingUser) {
      return { error: "Invalid parameters for deleting media item." };
    }

    const media = await this.mediaItems.findOne({ _id: mediaItem });
    if (!media) {
      return { error: `Media item with ID ${mediaItem} not found.` };
    }

    if (media.owner !== requestingUser) {
      return { error: "Permission denied: You can only delete media items you own." };
    }

    // Delete the media item itself
    await this.mediaItems.deleteOne({ _id: mediaItem });

    // Delete any associated access control records
    await this.accessControlRecords.deleteMany({ mediaItemId: mediaItem });

    return {};
  }

  // --- Queries ---

  /**
   * _getMediaItemById (mediaItemId: MediaItem): (mediaItem: MediaItems)
   *
   * **purpose**: Internal query to retrieve a media item by its ID, without access control checks.
   *
   * **state**: (See `uploadMedia` for MediaItems state)
   *
   * **effects**: Returns the MediaItem object if found, otherwise an empty array.
   */
  async _getMediaItemById({ mediaItemId }: { mediaItemId: MediaItem }): Promise<MediaItems[]> {
    if (!mediaItemId) {
      return [];
    }
    const mediaItem = await this.mediaItems.findOne({ _id: mediaItemId });
    return mediaItem ? [mediaItem] : [];
  }

  /**
   * _getAccessForUser (mediaItemId: MediaItem, userId: User): (accessRecords: AccessControlRecords[])
   *
   * **purpose**: Internal query to get access control records for a specific user and media item.
   *
   * **state**: (See `AccessControlRecords` state)
   *
   * **effects**: Returns an array of AccessControlRecords matching the criteria.
   */
  async _getAccessForUser({
    mediaItemId,
    userId,
  }: {
    mediaItemId: MediaItem;
    userId: User;
  }): Promise<AccessControlRecords[]> {
    if (!mediaItemId || !userId) {
      return [];
    }
    return this.accessControlRecords.find({ mediaItemId: mediaItemId, userId: userId }).toArray();
  }

  /**
   * _getMediaItemsByOwner (ownerId: User): (mediaItems: MediaItems[])
   *
   * **purpose**: Internal query to retrieve all media items owned by a specific user.
   *
   * **state**: (See `uploadMedia` for MediaItems state)
   *
   * **effects**: Returns an array of MediaItem objects owned by the specified user.
   */
  async _getMediaItemsByOwner({ ownerId }: { ownerId: User }): Promise<MediaItems[]> {
    if (!ownerId) {
      return [];
    }
    return this.mediaItems.find({ owner: ownerId }).toArray();
  }

  /**
   * _getPublicMediaItems (): (mediaItems: MediaItems[])
   *
   * **purpose**: Internal query to retrieve all publicly accessible media items.
   *
   * **state**: (See `uploadMedia` for MediaItems state)
   *
   * **effects**: Returns an array of MediaItem objects where `accessControl` is "public".
   */
  async _getPublicMediaItems(): Promise<MediaItems[]> {
    return this.mediaItems.find({ accessControl: "public" }).toArray();
  }

  /**
   * move(mediaId: String, newFilePath: String)`
    *   **Require:** `mediaId` exists. `newRelativePath` specifies a valid pathway within
    * the storage workspace for the user.
    *   **Effect:**
        *   Updates the `filePath` of the `MediaFile` object corresponding to `mediaId` to
        * reflect the new location.Physically moves the file data in app storage.[^1]

[^1:] App storage is within the user's local storage. The cloudURL doesn't change.
   */
  async move({ mediaId, newFilePath }: { mediaId: string; newFilePath: string }): Promise<Empty> {
    if (!mediaId || !newFilePath) {
      return { error: "Invalid parameters for moving media item." };
    }
    const media = await this.mediaItems.findOne({ _id: mediaId as MediaItem });
    if (!media) {
      return { error: `Media item with ID ${mediaId} not found.` };
    }
    // Update the filePath to the new location
    await this.mediaItems.updateOne(
      { _id: mediaId as MediaItem },
      { $set: { filePath: newFilePath } }
    );
    return {};
  }

  /**
   * `createFolder(filePath: String, name: String)`
    *   **Require:** `filePath` is valid. `name` is unique within the folder the `filePath`.
    *   **Effect:** Creates a new folder structure within the app's managed storage.
   */
  async createFolder({ filePath, name }: { filePath: string; name: string }): Promise<Empty> {
    if (!filePath || !name) {
      return { error: "Invalid parameters for creating folder." };
    }
    // In a real implementation, this would involve filesystem operations. Here, we just simulate the action.
    // For example, we could check if a folder with the same name already exists at the given path.
    // Since this is a conceptual implementation, we'll assume success.
    return {};
  }

  /**
   * `updateContext(mediaId: String, extractionResult: Dictionary[String:String])`
    *   **Require:** `mediaId` exists. `extractionResult` is a valid structured Dictionary of string to string that provides information about the text in the mediafile with mediaId.[^2]
    *   **Effect:** Updates the `context` field of the `MediaFile` corresponding to `mediaId` with the
    *  provided `extractionResult`. If context field doesn't exist, create one and updates with extractionResult.
   */
  async updateContext({ mediaId, extractionResult }: { mediaId: string; extractionResult: Record<string, string> }): Promise<Empty> {
    if (!mediaId || !extractionResult) {
      return { error: "Invalid parameters for updating context." };
    }
    const media = await this.mediaItems.findOne({ _id: mediaId as MediaItem });
    if (!media) {
      return { error: `Media item with ID ${mediaId} not found.` };
    }
    // see if there's context field
    // If context field doesn't exist, create one and updates with extractionResult.
    await this.mediaItems.updateOne(
      { _id: mediaId as MediaItem },
      { $set: { context: extractionResult } }
    );
    return {};
  }
  /**
   * *   `addTranslatedText(mediaId: String, translatedText: Dictionary[String:String])`
    *   **Require:** `mediaId` exists. `translatedText` is a valid structured Dictionary of string
    * to string that provides information about the text in the mediafile with mediaId.[^2]
    *   **Effect:** Appends the `outputVersion` to the `translatedVersions` list of the `MediaFile`
    * corresponding to `mediaId`.
[^2:] These two actions aren't accessible by users, they are meant to be called by the app only,
and so the translatedText or extractionResult given always corresponds to the media identified by
mediaId.
   */
  async addTranslatedText({ mediaId, translatedText }: { mediaId: string; translatedText: Record<string, string> }): Promise<Empty> {
    if (!mediaId || !translatedText) {
      return { error: "Invalid parameters for adding translated text." };
    }
    const media = await this.mediaItems.findOne({ _id: mediaId as MediaItem });
    if (!media) {
      return { error: `Media item with ID ${mediaId} not found.` };
    }
    // see if there's translatedVersions field
    // If translatedVersions field doesn't exist, create one and updates with translatedText.
    await this.mediaItems.updateOne(
      { _id: mediaId as MediaItem },
      { $push: { translatedVersions: translatedText } }
    );
    return {};
  }
}

```
