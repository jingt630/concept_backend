[@concept-design-overview](../../background/concept-design-overview.md)

[@concept-specifications](../../background/concept-specifications.md)

[@implementing-concepts](../../background/implementing-concepts.md)

[@TranslationConcept](../../concepts/Translation/Translation.md)

# implement: Translation

# response:

# file: src/Translation/TranslationConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Declare collection prefix, use concept name
const PREFIX = "Translation" + ".";

// Generic types of this concept
type filePath = ID; // Assuming filePath is an ID for reference
type TranslationID = ID;
type OriginalTextID = ID;

/**
 * A set of Translations with
 *   imagePath of type filePath
 *   transTextId of type String
 *   targetLanguage of type String
 *   originalTextId of type String
 *   translatedText of type String
 */
interface Translations {
  _id: TranslationID;
  imagePath: filePath;
  transTextId: string;
  targetLanguage: string;
  originalTextId: OriginalTextID;
  translatedText: string;
}

export default class TranslationConcept {
  translations: Collection<Translations>;

  constructor(private readonly db: Db) {
    this.translations = this.db.collection(PREFIX + "translations");
  }

  /**
   * createTranslation (imagePath: filePath, targetLanguage: String, originalText: String, originalTextId: String): (translation: Translation)
   *
   * **requires**: `imagePath` exists in the app. `targetLanguage` is a real language.
   *
   * **effects**: Generates a `Translation` with a unique `transTextId` based on `imagePath` and `originalTextId`. `translatedText` is generated by the AI in the `targetLanguage` from the `originalText`. Stores the `targetLanguage` and `originalText`.
   */
  async createTranslation({
    imagePath,
    targetLanguage,
    originalText,
    originalTextId,
  }: {
    imagePath: filePath;
    targetLanguage: string;
    originalText: string;
    originalTextId: OriginalTextID;
  }): Promise<{ translation: TranslationID }> {
    // TODO: Implement AI-assisted translation
    // For now, we'll simulate a translation and create a dummy transTextId
    const translatedText = `AI translated: "${originalText}" to ${targetLanguage}`;
    const transTextId = freshID(); // Generate a unique ID for the translated text

    const newTranslation: Translations = {
      _id: freshID(),
      imagePath,
      transTextId,
      targetLanguage,
      originalTextId,
      translatedText,
    };

    await this.translations.insertOne(newTranslation);

    return { translation: newTranslation._id };
  }

  /**
   * editTranslation (translation: Translation, newText: String)
   *
   * **requires**: `translation` exists.
   *
   * **effects**: Changes the `translatedText` in the `translation` to `newText`.
   */
  async editTranslation({
    translation,
    newText,
  }: {
    translation: TranslationID;
    newText: string;
  }): Promise<Empty> {
    const result = await this.translations.updateOne(
      { _id: translation },
      { $set: { translatedText: newText } },
    );

    if (result.matchedCount === 0) {
      return { error: "Translation not found" };
    }

    return {};
  }

  /**
   * changeLanguage (translation: Translation, newTargetLang: String)
   *
   * **requires**: `translation` exists. `newTargetLang` is a real language.
   *
   * **effects**: Changes the `targetLanguage` to `newTargetLang`. Sets `translatedText` to a new translated version in the `newTargetLang` generated by the AI.
   */
  async changeLanguage({
    translation,
    newTargetLang,
  }: {
    translation: TranslationID;
    newTargetLang: string;
  }): Promise<Empty> {
    const existingTranslation = await this.translations.findOne({
      _id: translation,
    });

    if (!existingTranslation) {
      return { error: "Translation not found" };
    }

    // TODO: Implement AI-assisted translation for the new language
    const translatedText = `AI re-translated "${existingTranslation.originalTextId}" to ${newTargetLang}`;

    const result = await this.translations.updateOne(
      { _id: translation },
      {
        $set: {
          targetLanguage: newTargetLang,
          translatedText: translatedText,
        },
      },
    );

    if (result.matchedCount === 0) {
      return { error: "Translation not found during update" };
    }

    return {};
  }

  // Optional: Add a query to retrieve a translation
  /**
   * _getTranslation (translationId: TranslationID): (translation: Translation)
   *
   * **requires**: `translationId` exists.
   *
   * **effects**: Returns the translation with the given ID.
   */
  async _getTranslation({
    translationId,
  }: {
    translationId: TranslationID;
  }): Promise<
    | Array<{
        translation: {
          _id: TranslationID;
          imagePath: filePath;
          transTextId: string;
          targetLanguage: string;
          originalTextId: OriginalTextID;
          translatedText: string;
        };
      }>
    | Array<{ error: string }>
  > {
    const translation = await this.translations.findOne({ _id: translationId });

    if (!translation) {
      return [{ error: "Translation not found" }];
    }

    return [
      {
        translation: {
          _id: translation._id,
          imagePath: translation.imagePath,
          transTextId: translation.transTextId,
          targetLanguage: translation.targetLanguage,
          originalTextId: translation.originalTextId,
          translatedText: translation.translatedText,
        },
      },
    ];
  }
}
```
